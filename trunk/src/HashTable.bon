class HashTable {

(**
   Author: Lihan Li
   Date  : 01 Jun 2011
*)

(* Properties *)
table : array (String * Top);

(* Functions *)
size = { |() -> lengthv !this.table }

(**
    Making - with default size 
    Example : let hashTable = HashTable.make0();;
*)
static make0 = { |() ->  let ht = new HashTable in
                         ht.table = newarray ("",(-1):Top) 10000;
                         ht
}
(**
    Making - accepts two parameters for size and default value
    Example : let hashTable = HashTable.make(1000, -1);;
*)
static make = { |(size,default) ->  let ht = new HashTable in
                                    ht.table = newarray ("",(default):Top) size;
                                    ht
}

(* It tells the usage percentage in hashtable*)
percent = { |() -> Exception "NotImplemented" }


(* It returns the hash for a string *)
get_hash = { fun key -> let result = Ref 0 in 
                        for i=0 to ((lengthstring key) - 1) do (
                            result = !result + (char2int(key getcharstring i))
                        ); 
                        !result 
}


get_index = { fun hash -> hash modint this.size() }

(* It tells whether the index has already used *)
is_available = { fun index -> !(entry(!this.table,index)) == ("", (-1):Top) }

(* It accepts the string key and returns the first available position in array *)
get_position = { fun k -> let hash = Ref (this.get_hash(k)) in
                          let found = Ref (False) in
                          let position = Ref (-1) in
                              while (!found == False) do
                              (
                                  position = this.get_index(!hash);
                                  if fst(!(entry(!this.table, !position)))==k || this.is_available(!position) == True
                                      then found = True
                                  else  hash = !hash + 1
                              );
                              !position
}


(* Public method, it accepts a (key, value) pair and inserts into hash table *)
put = { |(k,v) -> let position = Ref (this.get_position(k)) in
                  entry(!this.table,!position) = (k,v) 
}

(* Public method, it accpets a string key, and returns the related value *)
get = { fun k -> let hash = Ref (this.get_hash(k)) in
                 let found = Ref (False) in
                 let value = Ref ("KeyNotFound": Top) in
                 let index = Ref (this.get_index(!hash)) in
                 let key = Ref (fst (!(entry(!this.table, !index)))) in
                     while (!found == False) do
                     (      
                         if (this.is_available(!index)) == True
                             then found = True;
                                  value = Exception "KeyNotFound"                     
                         else if !key == k
                                  then found = True;
                                       value = snd (!(entry(!this.table, !index)))
                              else hash = !hash + 1
                     );
                     !value
}



(* For debugging purpose, not used 
debug = { fun index -> !(entry(!this.table,index)) }
*)

}

(* Test

let ha = HashTable.make0();;

ha.put("key", "value");;

ha.get("key");;

ha.put("key", "new value");;

ha.get("key");;


*)
